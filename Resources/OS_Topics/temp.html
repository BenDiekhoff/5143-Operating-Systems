<table cellspacing="0" class="sites-layout-name-one-column sites-layout-hbox" xmlns="http://www.w3.org/1999/xhtml"><tbody><tr><td><a><h2><a></a><hr/>Definition<hr/></h2><p>A set of two or more processes are deadlocked if they are blocked (i.e., in the waiting state) each holding a resource and waiting to acquire a resource held by another process in the set.</p>or<p>A process is deadlocked if it is waiting for an event which is never going to happen.</p><br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/deadlock.png"/>&nbsp;<br/><br/>Example:<ul><li>a system has two tape drives</li><li>two processes are deadlocked if each holds one tape drive and has requested the other</li></ul><br/>Example: semaphores A and B, each initialized to 1:<pre>      P_0          P_1
    ---          ---
    A.wait();    B.wait();
    B.wait();    A.wait();
    A.signal();  B.signal();
    B.signal();  A.signal();
</pre>Deadlock depends on the dynamics of the execution.&nbsp;<br/>Illustrates that it is difficult to identify and test for deadlocks which may occur only under certain circumstances.&nbsp;<br/><br/>System model:<br/><ul><li>resource types: R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>n</sub></li><li>each resource R has W<sub>i</sub>&nbsp;instances</li><li>each process utilizes a resource as follows:</li></ul><pre>      // request (e.g., open() system call)
    // use
    // release (e.g., close() system call)
</pre>Any instance of a resource type can be used to satisfy a request of that resource.</a><a><h2><a></a><hr/>Conditions Necessary for Deadlock<hr/></h2><u>All</u>&nbsp;of the following four necessary conditions&nbsp;<u>must</u>&nbsp;hold simultaneously for deadlock to occur:<ul><li><b>mutual exclusion:</b>&nbsp;only one process can use a resource at a time.</li><li><b>hold and wait:</b>&nbsp;a process holding at least one resource is waiting to acquire additional resources which are currently held by other processes.</li><li><b>no preemption:</b>&nbsp;a resource can only be released voluntarily by the process holding it.</li><li><b>circular wait:</b>&nbsp;a cycle of process requests exists (i.e.,&nbsp;<i>P</i><sub>0</sub>&nbsp;is waiting for a resource hold by&nbsp;<i>P</i><sub>1</sub>&nbsp;who is waiting for a resource held by&nbsp;<i>P</i><sub><i>j</i></sub>&nbsp;... who is waiting for a resource held by&nbsp;<i>P</i><sub>(<i>n</i>-1)</sub>&nbsp;which is waiting for a resource held by&nbsp;<i>P</i><sub><i>n</i></sub>&nbsp;which is waiting for a resource held by&nbsp;<i>P</i><sub>0</sub>).</li></ul>Circular wait implies the hold and wait condition. Therefore, these conditions are not completely independent.</a><a><h2><a></a><hr/>Resource Allocation Graph Syntax<hr/></h2>A resource allocation graph contains a set of vertices V and a set of edges E.&nbsp;<br/><br/>V is partitioned into two types:<ul><li><tt>P = {P<sub>1</sub>, P<sub>2</sub>, ..., P<sub>n</sub>}</tt>&nbsp;is the set of all processes.</li><li><tt>R = {R<sub>1</sub>, R<sub>2</sub>, ..., R<sub>m</sub>}</tt>&nbsp;is the set of all resources.</li></ul>A&nbsp;<i>request</i>&nbsp;is represented by a directed edge from&nbsp;<i>P</i><sub><i>i</i></sub>&nbsp;to&nbsp;<i>R</i><sub><i>j</i></sub>.&nbsp;<br/>An&nbsp;<i>assignment</i>&nbsp;is represented by a directed edge from&nbsp;<i>R</i><sub>j</sub>&nbsp;to&nbsp;<i>P</i><sub><i>i</i></sub>.&nbsp;<br/><ul><li>resource type with four instances:&nbsp;<br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/resource.png"/>&nbsp;<br/><br/></li><li><i>P<sub>i</sub></i>&nbsp;requests an instance of&nbsp;<i>R<sub>j</sub></i>&nbsp;<br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/request.png"/>&nbsp;<br/><br/></li><li><i>P<sub>i</sub></i>&nbsp;is holding an instance of&nbsp;<i>R<sub>j</sub></i>&nbsp;<br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/hold.png"/></li></ul></a><a><h2><a></a><hr/>Sample Resource Allocation Graphs<hr/></h2><ul><li><b>resource allocation graph without deadlock:</b>&nbsp;<br/><br/><ul><li><i>P</i><sub>1</sub>&nbsp;wants a resource held by&nbsp;<i>P</i><sub>2</sub></li><li>no process is requesting an instance of&nbsp;<i>R</i><sub>4</sub>&nbsp;<br/></li><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc72.png"/>&nbsp;<br/><small>(regenerated from [OSC] Fig. 7.2 on p. 288)</small>&nbsp;<br/><br/></ul></li><li><b>resource allocation graph with a cycle and deadlock:</b><ul><br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc73.png"/>&nbsp;<br/><small>(regenerated from [OSC] Fig. 7.3 on p. 289)</small>&nbsp;<br/><br/></ul></li><li><b>resource allocation graph with a cycle but no deadlock:</b>&nbsp;<br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc74.png"/>&nbsp;<br/><small>(regenerated from [OSC] Fig. 7.4 on p. 289)</small>&nbsp;<br/></li></ul><br/></a><a><h2><a></a><hr/><i>Possibility</i>&nbsp;of Deadlock<hr/></h2><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/deadlockstates.png"/>&nbsp;<br/><small>(regenerated from [OSC] Fig. 7.5 on p. 295)</small>&nbsp;<br/><br/><p>If a resource allocation graph contains no cycles, then no process is deadlocked.</p><p>If a resource allocation graph contains a cycle, then a deadlock&nbsp;<u>may</u>&nbsp;exist.</p><p>Therefore, a cycle means deadlock is&nbsp;<i>possible</i>, but not necessarily&nbsp;<i>present</i>.</p><p>A cycle is not sufficient proof of the presence of deadlock. A cycle is a&nbsp;<i>necessary</i>&nbsp;condition for deadlock, but not a&nbsp;<i>sufficient</i>&nbsp;condition for deadlock.</p><p>difference between&nbsp;<i>necessary</i>&nbsp;and&nbsp;<i>sufficient</i></p><ul><li>getting a 4.0 GPA is&nbsp;<i>sufficient</i>&nbsp;to graduate, but it is not&nbsp;<i>necessary</i></li><li>passing CPS 346 (OS) is&nbsp;<i>necessary</i>, but not&nbsp;<i>sufficient</i></li></ul><h2><a></a><hr/>Resource Allocation Graph Summary<hr/></h2><ul><li>if a resource allocation graph does not contain a cycle, then there is absolutely no possibility of deadlock</li><li>if a resource allocation graph contains a cycle, then there is the possibility of deadlock</li><li>if each resource type has exactly one instance, then a cycle implies that deadlock has occurred</li><li>if the cycle involves only a set of resource types, each of which has only a single instance, then a deadlock has occurred</li><li>if all instances of a resource are allocated to a process in a cycle, then there is deadlock</li></ul></a><a><h2><a></a><hr/>Methods for Handling Deadlock<hr/></h2>The following are methods for addressing the possibility of deadlock:<ul><li>ensure that the system never enters a deadlocked state:<ul><li>deadlock prevention</li><li>deadlock avoidance</li></ul></li><li>deadlock detection and recovery: allow the system to enter a deadlocked state, then deal with and eliminate the problem</li><li>ignore the problem: approached used by many operating systems including UNIX and Windows, and the Java VM</li></ul></a><a><h2><a></a><hr/>Deadlock Prevention<hr/></h2>Restrain the ways resource requests are made so to prevent one of the&nbsp;</a><a>four conditions</a>&nbsp;necessary for deadlock.<ul><li><b>prevent mutual exclusion</b><ul><li>use only sharable resources (e.g., a read-only file)</li><li>impossible for practical systems</li></ul><br/></li><li><b>prevent hold and wait</b><ul><li>methods<ul><li>preallocate<ul><li>do not pick up one chopstick if you cannot pick up the other</li><li>for a process that copies data from DVD drive to a file on disk and then prints it from there:<ol><li>request DVD drive</li><li>request disk file</li><li>request printer</li></ol></li><li>all system calls requesting resources must proceed all other system calls</li></ul><br/></li><li>a process can request resources only when it has none<ol><li>request DVD drive and disk file</li><li>release DVD drive and disk file</li><li>request disk file and printer (no guarantee data will still be there)</li><li>release disk file and printer</li></ol></li></ul><br/></li><li>inefficient</li><li>starvation possible</li></ul><br/></li><li><b>prevent no preemption</b>&nbsp;(i.e., allow preemption, and permit the OS to take away resources from a process)<ul><li>when a process must wait, it must release its resources</li><li>some resources cannot be feasibly preempted (e.g., printers, tape drives)</li></ul><br/></li><li><b>prevent circular wait</b><ul><li>impose a total ordering on resources</li><li>only allow requests in an increasing order</li></ul></li></ul>Usually a deadlock prevention approach is simply unreasonable.<a><h2><a></a><hr/>Deadlock Avoidance<hr/></h2><p>This requires that the system has some information available up front. Each process declares the maximum number of resources of each type which it may need. Dynamically examine the resource allocation state to ensure that there can never be a circular-wait condition.</p><p>The system's resource-allocation state is defined by the number of available and allocated resources, and the maximum possible demands of the processes. When a process requests an available resource, the system must decide if immediate allocation leaves the system in a&nbsp;<i>safe state</i>.</p><p>The system is in a safe state if there exists a safe sequence of all processes:</p><p>Sequence &lt; P<sub>1</sub>, P<sub>2</sub>, ... P<sub><i>n</i></sub>&nbsp;&gt; is safe for the current allocation state if, for each P<sub><i>i</i></sub>, the resources which P<sub><i>i</i></sub>&nbsp;can still request can be satisfied by</p><ul><li>the currently available resources plus</li><li>the resources held by all of the P<sub><i>j</i></sub>'s, where&nbsp;<i>j</i>&nbsp;&lt;&nbsp;<i>i</i>.</li></ul><p>If the system is in a safe state, there can be no deadlock. If the system is in an unsafe state, there is the&nbsp;<i>possibility</i>&nbsp;of deadlock.</p><p><b>Example:</b>&nbsp;consider a system with 12 magnetic tapes and 3 processes (P<sub>0</sub>, P<sub>1</sub>, and P<sub>2</sub>):</p></a><table><tbody><tr><td>available = 3</td></tr><tr><th>Process</th><th>Maximum Needs</th><th>Holding</th><th>Needs</th></tr><tr><td>P<sub>0</sub></td><td>10</td><td>5</td><td>5</td></tr><tr><td>P<sub>1</sub></td><td>4</td><td>2</td><td>2</td></tr><tr><td>P<sub>2</sub></td><td>9</td><td>2</td><td>7</td></tr></tbody></table><p>Is the system in a safe state? If so, which sequence satisfies the safety criteria?</p><br/><table><tbody><tr><td>available = 2</td></tr><tr><th>Process</th><th>Maximum Needs</th><th>Holding</th><th>Needs</th></tr><tr><td>P<sub>0</sub></td><td>10</td><td>5</td><td>5</td></tr><tr><td>P<sub>1</sub></td><td>4</td><td>2</td><td>2</td></tr><tr><td>P<sub>2</sub></td><td>9</td><td>3</td><td>6</td></tr></tbody></table><p>Is the system in a safe state? If so, which sequence satisfies the safety criteria?</p><br/><p>In this scheme, a process which requests a resource that is currently available, may still have to wait. Thus, resource utilization may be lower than it would otherwise be.</p><a><h2><a></a><hr/>Deadlock Avoidance Algorithms<hr/></h2>Two deadlock avoidance algorithms:<ul><li>resource-allocation graph algorithm</li><li>Banker's algorithm</li></ul><br/><b>Resource-allocation graph algorithm</b><ul><li>only applicable when we only have 1 instance of each resource type</li><li>claim edge (dotted edge), like a&nbsp;<i>future</i>&nbsp;request edge</li><li>when a process requests a resource, the claim edge is converted to a request edge</li><li>when a process releases a resource, the assignment edge is converted to a claim edge</li><li>cycle detection:&nbsp;<b><i>O</i>(<i>n</i>²)</b></li></ul><b>Banker's Algorithm</b><ul><li>a classic deadlock avoidance algorithm</li><li>more general than resource-allocation graph algorithm (handles multiple instances of each resource type), but</li><li>is less efficient</li></ul><h2><a></a><hr/>Resource-allocations graphs for deadlock avoidance<hr/></h2><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc76.png"/>&nbsp;<br/><br/>(regenerated from [OSC] Fig. 7.6 on p. 297)&nbsp;<br/><br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc77.png"/>&nbsp;<br/><br/>(regenerated from [OSC] Fig. 7.7 on p. 297)&nbsp;<br/><br/></a><a><h2><a></a><hr/>Banker's Algorithm<hr/></h2>We call Banker's algorithm when a request for R is made. Let&nbsp;<tt>n</tt>&nbsp;be the number of processes in the system, and&nbsp;<tt>m</tt>&nbsp;be the number of resource types.&nbsp;<br/><br/>Define:<ul><li><tt>available[m]</tt>: the number of units of R currently unallocated (e.g.,&nbsp;<tt>available[3] = 2</tt>)</li><li><tt>max[n][m]</tt>: describes the maximum demands of each process (e.g.,&nbsp;<tt>max[3][1] = 2</tt>)</li><li><tt>allocation[n][m]</tt>: describes the current allocation status ( e.g.,&nbsp;<tt>allocation[5][1] = 3</tt>)</li><li><tt>need[n][m]</tt>: describes the&nbsp;<i>remaining</i>&nbsp;possible need (i.e.,&nbsp;<tt>need[i][j] = max[i][j] - allocation[i][j]</tt>)</li></ul><b>Resource-request algorithm</b>:&nbsp;<br/><br/>Define:<ul><li><tt>request[n][m]</tt>: describes the current outstanding requests of all processes (e.g.,&nbsp;<tt>request[2][1] = 3</tt>)</li></ul><ol><li>If&nbsp;<tt>request[i][j] &lt;= need[i][j]</tt>, to to step 2; otherwise, raise an error condition.</li><li>If&nbsp;<tt>request[i][j] &gt; available[j]</tt>, then the process must wait.</li><li>Otherwise,&nbsp;<i>pretend</i>&nbsp;to allocate the requested resources to P<sub><i>i</i></sub>&nbsp;:<pre>      available[j] = available[j] - request[i][j]
    allocation[i][j] = allocation[i][j] + request[i][j]
    need[i][j] = need[i][j] - request[i][j]</pre>Once the resources are&nbsp;<i>allocated</i>, check to see if the system state is safe. If unsafe, the process must wait and the old resource-allocated state is restored.</li></ol><b>Safety algorithm</b>&nbsp;(to check for a safe state):&nbsp;<br/><ol><li>Let&nbsp;<tt>work</tt>&nbsp;be an integer array of length&nbsp;<tt>m</tt>, initialized to&nbsp;<tt>available</tt>.<br/>Let&nbsp;<tt>finish</tt>&nbsp;be a boolean array of length&nbsp;<tt>n</tt>, initialized to&nbsp;<tt>false</tt>.</li><br/><li>Find an&nbsp;<tt>i</tt>&nbsp;such that both:<ul><li><tt>finish[i] == false</tt></li><li><tt>need[i] &lt;= work</tt></li></ul>If no such&nbsp;<tt>i</tt>&nbsp;exists, go to step 4</li><br/><li><tt>work = work + allocation[i];</tt><br/><tt>finish[i] = true;</tt><br/>Go to step 2</li><br/><li>If&nbsp;<tt>finish[i] == true</tt>&nbsp;for all&nbsp;<tt>i</tt>, then the system is in a safe state, otherwise unsafe.</li></ol>Run-time complexity:&nbsp;<b><i>O</i>(<i>m</i>&nbsp;×&nbsp;<i>n</i>²)</b>.&nbsp;<br/><p><i>Example</i>: consider a system with 5 processes (P<sub>0</sub>&nbsp;... P<sub>4</sub>) and 3 resources types (<tt>A(10) B(5) C(7)</tt>)</p><p>resource-allocation state at time t<sub>0</sub>:</p></a><table><tbody><tr><th>Process</th><th>Allocation</th><th>Max</th><th>Need</th><th>Available</th></tr><tr><td></td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td></tr><tr><td>P<sub>0</sub></td><td>0</td><td>1</td><td>0</td><td>7</td><td>5</td><td>3</td><td>7</td><td>4</td><td>3</td><td>3</td><td>3</td><td>2</td></tr><tr><td>P<sub>1</sub></td><td>2</td><td>0</td><td>0</td><td>3</td><td>2</td><td>2</td><td>1</td><td>2</td><td>2</td></tr><tr><td>P<sub>2</sub></td><td>3</td><td>0</td><td>2</td><td>9</td><td>0</td><td>2</td><td>6</td><td>0</td><td>0</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>0</td><td>1</td><td>1</td></tr><tr><td>P<sub>4</sub></td><td>0</td><td>0</td><td>2</td><td>4</td><td>3</td><td>3</td><td>4</td><td>3</td><td>1</td></tr></tbody></table><p>Is the system in a safe state? If so, which sequence satisfies the safety criteria?</p><p><tt>&lt; P<sub>1</sub>, P<sub>3</sub>, P<sub>4</sub>, P<sub>2</sub>, P<sub>0</sub>&nbsp;&gt;</tt></p><p>Now suppose, P<sub>1</sub>&nbsp;requests an additional instance of A and 2 more instances of type C.</p><p><tt>request[1] = (1,0,2)</tt></p><ol><li>check if&nbsp;<tt>request[1] &lt;= need[i]</tt>&nbsp;(yes)</li><li>check if&nbsp;<tt>request[1] &lt;= available[i]</tt>&nbsp;(yes)</li><li>do pretend updates to the state</li></ol><table><tbody><tr><th>Process</th><th>Allocation</th><th>Max</th><th>Need</th><th>Available</th></tr><tr><td></td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td></tr><tr><td>P<sub>0</sub></td><td>0</td><td>1</td><td>0</td><td>7</td><td>5</td><td>3</td><td>7</td><td>4</td><td>3</td><td>3</td><td>3</td><td>2</td></tr><tr><td>P<sub>1</sub></td><td>3</td><td>0</td><td>2</td><td>3</td><td>2</td><td>2</td><td>0</td><td>2</td><td>0</td></tr><tr><td>P<sub>2</sub></td><td>3</td><td>0</td><td>2</td><td>9</td><td>0</td><td>2</td><td>6</td><td>0</td><td>0</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>1</td><td>1</td><td>2</td><td>2</td><td>2</td><td>0</td><td>1</td><td>1</td></tr><tr><td>P<sub>4</sub></td><td>0</td><td>0</td><td>2</td><td>4</td><td>3</td><td>3</td><td>4</td><td>3</td><td>1</td></tr></tbody></table>Is the system in a safe state? If so, which sequence satisfies the safety criteria?<p>&lt;P<sub>1</sub>, P<sub>3</sub>, P<sub>4</sub>, P<sub>0</sub>, P<sub>2</sub>&gt;</p><p>Hence, we immediately grant the request.</p><br/><p>Will a request of (3,3,0) by P<sub>4</sub>&nbsp;be granted?</p><p>Will a request of (0,2,0) by P<sub>0</sub>&nbsp;be granted?</p><a><h2><a></a><hr/>Deadlock Detection<hr/></h2><ul><li>requires an algorithm which examines the state of the system to determine whether a deadlock has occurred</li><li>requires overhead<ul><li>run-time cost of maintaining necessary information and executing the detection algorithm</li><li>potential losses inherent in recovering from deadlock</li></ul></li></ul>Single instance of each resource type<ul><li>wait-graph</li><li>P<sub><i>i</i></sub>&nbsp;→ P<sub><i>j</i></sub>&nbsp;= P<sub><i>i</i></sub>&nbsp;&gt; R<sub><i>q</i></sub>&nbsp;and R<sub><i>q</i></sub>&nbsp;→ P<sub><i>j</i></sub></li><li>detect cycle:&nbsp;<b><i>O</i>(<i>n</i>²)</b></li><li>overhead: maintain the graph + invoke algorithm</li></ul><p><b>Resource-allocations graphs for deadlock detection</b></p>resource-allocation graph:&nbsp;<br/><br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc78a.png"/>&nbsp;<br/><br/>corresponding wait-for graph:&nbsp;<br/><br/><img src="http://academic.udayton.edu/SaverioPerugini/courses/cps346/lecture_notes/images/osc78b.png"/>&nbsp;<br/><br/>(regenerated from [OSC] Fig. 7.8 on p. 302)<p>Multiple instances of a resource type: use an algorithm similar to Banker's, which simply investigates&nbsp;<i>every</i>&nbsp;possible allocation sequence for the processes which remain to be completed.</p>Define:<ul><li><tt>available[m]</tt></li><li><tt>allocation[n][m]</tt></li><li><tt>request[n][m]</tt><br/>with their usual semantics.</li></ul>Algorithm:<ol><li>Let&nbsp;<tt>work</tt>&nbsp;be an integer array of length&nbsp;<tt>m</tt>, initialized to&nbsp;<tt>available</tt>.&nbsp;<br/><br/>Let finish be a boolean array of length&nbsp;<tt>n</tt>.&nbsp;<br/><br/>For all&nbsp;<tt>i</tt>, if&nbsp;<tt>allocation[i] != 0</tt>, then&nbsp;<tt>finish[i] = false;</tt>&nbsp;<br/>Otherwise&nbsp;<tt>finish[i] = true</tt>.</li><br/><li>Find an&nbsp;<tt>i</tt>&nbsp;such that both<ul><li><tt>finish[i] == false //</tt>&nbsp;P<sub><i>i</i></sub>&nbsp;is currently&nbsp;<i>not</i>&nbsp;involved in a deadlock</li><li><tt>request[i] &lt;= work</tt></li></ul>If no such&nbsp;<tt>i</tt>&nbsp;exists, go to step 4</li><br/><li>// reclaim the resources of process P<sub><i>i</i></sub>&nbsp;<br/><tt>work = work + allocation[i];</tt>&nbsp;<br/><tt>finish[i] = true;</tt>&nbsp;<br/>Go to step 2</li><br/><li>If&nbsp;<tt>finish[i] == false</tt>&nbsp;for some&nbsp;<tt>i</tt>,&nbsp;<br/>Then the system is in a deadlocked state.&nbsp;<br/>Moreover, if&nbsp;<tt>finish[i] == false</tt>, then process P<sub><i>i</i></sub>&nbsp;is deadlocked.</li></ol><p>Run-time complexity:&nbsp;<b><i>O</i>(<i>m</i>&nbsp;×&nbsp;<i>n</i>²)</b>.</p><p>Example: consider a system with 5 processes (P<sub>0</sub>&nbsp;.. P<sub>4</sub>) and 3 resources types (<tt>A(7) B(2) C(6)</tt>)</p><p>resource-allocation state at time t<sub>0</sub>:</p></a><table><tbody><tr><th>Process</th><th>Allocation</th><th>Request</th><th>Available</th></tr><tr><td></td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td></tr><tr><td>P<sub>0</sub></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>P<sub>1</sub></td><td>2</td><td>0</td><td>0</td><td>2</td><td>0</td><td>2</td></tr><tr><td>P<sub>2</sub></td><td>3</td><td>0</td><td>3</td><td>0</td><td>0</td><td>0</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>P<sub>4</sub></td><td>0</td><td>0</td><td>2</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><p>Is the system in a deadlocked state?</p><p>If not, which sequence results in&nbsp;<tt>finish[i] == true</tt>&nbsp;for all&nbsp;<tt>i</tt>&nbsp;?</p><p>&lt; P<sub>0</sub>, P<sub>2</sub>, P<sub>3</sub>, P<sub>1</sub>, P<sub>4</sub>&nbsp;&gt;</p><p>Now suppose, P<sub>2</sub>&nbsp;requests an additional instance of&nbsp;<tt>C</tt>:</p><table><tbody><tr><th>Process</th><th>Allocation</th><th>Request</th><th>Available</th></tr><tr><td></td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td><td>A</td><td>B</td><td>C</td></tr><tr><td>P<sub>0</sub></td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>P<sub>1</sub></td><td>2</td><td>0</td><td>0</td><td>2</td><td>0</td><td>2</td></tr><tr><td>P<sub>2</sub></td><td>3</td><td>0</td><td>3</td><td>0</td><td>0</td><td>1</td></tr><tr><td>P<sub>3</sub></td><td>2</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>P<sub>4</sub></td><td>0</td><td>0</td><td>2</td><td>0</td><td>0</td><td>2</td></tr></tbody></table><p>Is the system in a deadlocked state?&nbsp;&nbsp;&nbsp;&nbsp;Yes.</p><p>If not, which sequence results in&nbsp;<tt>finish[i] == true</tt>&nbsp;for all&nbsp;<tt>i</tt>&nbsp;?</p><p>Although we can reclaim the resources held by P<sub>0</sub>, the number of available resources is insufficient to fulfill the requests of the other processes.</p><p>Thus, a deadlock exists, consisting of processes P<sub>1</sub>, P<sub>2</sub>, P<sub>3</sub>, and P<sub>4</sub>.</p><b>When should we invoke the detection algorithm?</b>&nbsp;Depends on:<ul><li>how&nbsp;<i>often</i>&nbsp;is a deadlock likely to occur</li><li>how&nbsp;<i>many</i>&nbsp;processes will be affected by deadlock when it happens</li></ul><p>If deadlocks occur frequently, then the algorithm should be invoked frequently.</p><p>Deadlocks only occur when some process makes a request which cannot be granted (if this request is the completes a chain of waiting processes).</p><ul><li><b>Extreme:</b>&nbsp;invoke the algorithm every time a request is denied</li><li><b>Alternative</b>: invoke the algorithm at less frequent time intervals:<ul><li>once per hour</li><li>whenever CPU utilization &lt; 40%</li><li>disadvantage: cannot determine exactly which process 'caused' the deadlock</li></ul></li></ul><a><h2><a></a><hr/>Deadlock Recovery<hr/></h2>How to deal with deadlock:<ul><li>inform operator and let them decide how to deal with it manually</li><li>let the system&nbsp;<i>recover</i>&nbsp;from the deadlock automatically:<ul><li>abort or more of the deadlocked processes to break the circular wait</li><li>preempt some resources from one or more of the processes to break the circular wait</li></ul></li></ul><p><b>Process termination</b></p><p>Aborting a process is not easy; involves clean-up (e.g., file, printer).</p><ul><li>abort all deadlocked processes (disadvantage: wasteful)</li><li>abort one process at a time until the circular wait is eliminated<ul><li>disadvantage: lot of overhead; must re-run algorithm after each kill</li><li>how to determine which process to terminate? minimize cost<ul><li>priority of the process</li><li>how long has it executed? how much more time does it need?</li><li>how many and what type of resources has the process used?</li><li>how many more resources will the process need to complete?</li><li>how many processes will need to be terminated?</li><li>is the process interactive or batch?</li></ul></li></ul></li></ul><p><b>Resource Preemption</b></p><p>Incrementally preempt and re-allocate resources until the circular wait is broken.</p><ul><li>selecting a victim (see above)</li><li>rollback: what should be done with process which lost the resource?<br/>clearly it cannot continue; must rollback to a safe state (???) =&gt; total rollback</li><li>starvation: pick victim only small (finite) number of times; use number of rollbacks in decision</li></ul></a><a><h2><a></a><hr/>Summary<hr/></h2><ul><li>definition of deadlock</li><li>three methods of addressing deadlock<ul><li>ensure deadlock never arises<ul><li>deadlock prevention: ensure at least one of the four necessary conditions for deadlock never holds<ul><li>mutual exclusion</li><li>hold and wait</li><li>no preemption</li><li>circular wait</li></ul></li><li>deadlock avoidance<ul><li>less stringent, but requires&nbsp;<i>a priori</i>&nbsp;information</li><li>Banker's algorithm</li></ul></li></ul></li><li>deadlock detection and recovery<ul><li>terminate processes: selecting a victim</li><li>preempt resources<ul><li>selecting a victim</li><li>rollback</li><li>starvation</li></ul></li></ul></li><li>ignore the problem (most common approach)</li></ul><br/></li><li>there is no `silver bullet'</li><li>often a combination of approaches should be employed to permit us to use an optimal approach for each class of resources in the system</li></ul></a><a><h2><a></a><hr/>References</h2><ul><table><tbody><tr><td>[OSC]</td><td>A. Silberschatz, P.B. Galvin, and G. Gagne.&nbsp;<i>Operating Systems Concepts</i>. John Wiley and Sons, Inc., Eighth edition, 2009.</td></tr><tr><td>[OSCJ]</td><td>A. Silberschatz, P.B. Galvin, and G. Gagne.&nbsp;<i>Operating Systems Concepts with Java</i>. John Wiley and Sons, Inc., Seventh edition, 2007.</td></tr></tbody></table></ul></a></td></tr></tbody></table>